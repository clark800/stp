# wikilinks converts links of the form [[title]] to html <a> links based
# on the title to path mapping generated by the titlemap plugin.
# this should be applied to the markdown source prior to the markdown renderer.

wikilinks() {
    bs="$(printf '\b')"
    nx="$(printf '\nx')"
    n="${nx%x}"

    _find_wikilinks() {
        p='\[\[\([^[]*\)\]\]'
        # this function returns the contents of each double square bracket pair
        # one per line. it needs to handle potentially multiple wikilinks per
        # line of the input. to do this it searches for lines starting with
        # the wikilink pattern and when found it replaces this with the contents
        # and a newline then uses the P and D sed commands to print the contents
        # and continue with the rest of the line after the inserted newline.
        # then the second sed expression handles cases where the wikilink
        # pattern is not at the start of the line by inserting a newline prior
        # to the pattern and using the D sed command to drop everything before
        # that newline so that the next cycle will see the wikilink at the
        # start of the line
        sed -e "/^${p}/{s/${p}/\\1\\${n}/${n}P${n}D${n}}" -e "s/${p}/\\${n}&/;D"
    }

    _substitute() {
        link="$1"; path="$2"
        # there are edge cases when the link or href contain special characters
        # but these escapes should handle most common cases
        esclink="$(println "$link" | sed 's/[.*[]/\\&/g')"
        escaped="$(println "$link" | sed 's/[&]/\\&/g')"
        label="${escaped#*|}"
        left="${escaped%%|*}"
        title="${left%%#*}"
        fragment="${left#$title}"
        href="$(println "$path$fragment" | sed 's/[&]/\\&/g')"
        # use backspace as the sed delimiter so the label can contain almost
        # any character
        sed "s${bs}\\[\\[$esclink\\]\\]${bs}<a href=\"$href\">$label</a>${bs}g"
    }

    _substitute_all() {
        link="${1%%$n*}"
        links="${1#*$n}"
        if [ ! "$link" ]; then cat && return; fi
        left="${link%%|*}"
        title="${left%%#*}"
        if [ ! "$title" ]; then
            # skip links that look like [[#id]]
            # they should be interpreted as literal brackets around a [#id] link
            _substitute_all "$links"
            return
        fi
        slug_path="$TMP/titlemap/$(slugify "$title")"
        if [ ! -f "$slug_path" ]; then
            println "WARNING: page not found for wikilink '$title'" >&2
            _substitute_all "$links"
            return
        fi
        href="$ROOT/$(cat "$slug_path")"
        _substitute "$link" "$href" | _substitute_all "$links"
    }

    if [ ! -d "$TMP/titlemap" ]; then
        println "WARNING: titlemap not found; skipping wikilinks" >&2
        cat && return
    fi

    document="$(cat)"
    links="$(println "$document" | _find_wikilinks)"
    println "$document" | _substitute_all "$links$n"
}
